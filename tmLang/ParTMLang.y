-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParTMLang where
import AbsTMLang
import LexTMLang
import ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '*' { PT _ (TS _ 1) }
  '0' { PT _ (TS _ 2) }
  '1' { PT _ (TS _ 3) }
  '_' { PT _ (TS _ 4) }
  'accept' { PT _ (TS _ 5) }
  'l' { PT _ (TS _ 6) }
  'r' { PT _ (TS _ 7) }
  'reject' { PT _ (TS _ 8) }

L_TMIdent { PT _ (T_TMIdent $$) }


%%

TMIdent    :: { TMIdent} : L_TMIdent { TMIdent ($1)}

State :: { State }
State : TMIdent { AbsTMLang.State $1 }
NextCommand :: { NextCommand }
NextCommand : State { AbsTMLang.NContinue $1 }
            | 'accept' { AbsTMLang.NAccept }
            | 'reject' { AbsTMLang.NReject }
Symbol :: { Symbol }
Symbol : '*' { AbsTMLang.SWild }
       | '_' { AbsTMLang.SBlank }
       | '1' { AbsTMLang.STrue }
       | '0' { AbsTMLang.SFalse }
Direction :: { Direction }
Direction : '*' { AbsTMLang.DStay }
          | 'l' { AbsTMLang.DLeft }
          | 'r' { AbsTMLang.DRight }
Instruction :: { Instruction }
Instruction : State Symbol Symbol Direction NextCommand { AbsTMLang.Instruction $1 $2 $3 $4 $5 }
ListInstruction :: { [Instruction] }
ListInstruction : {- empty -} { [] }
                | ListInstruction Instruction { flip (:) $1 $2 }
Program :: { Program }
Program : ListInstruction { AbsTMLang.Program (reverse $1) }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

